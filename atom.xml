<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://richardsonjm.github.io/atom.xml" rel="self"/>
  <link href="http://richardsonjm.github.io/"/>
  <updated>2013-10-15T09:40:09-04:00</updated>
  <id>http://richardsonjm.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[anal v methodical]]></title>
    <link href="http://richardsonjm.github.io/blog/2013/10/13/anal-v-methodical/"/>
    <updated>2013-10-13T11:12:00-04:00</updated>
    <id>http://richardsonjm.github.io/blog/2013/10/13/anal-v-methodical</id>
    <content type="html"><![CDATA[<h1>POODR and Everybody Poops</h1>

<p><img src="http://img1.imagesbn.com/p/9780321721334_p0_v2_s260x420.JPG" alt="POODR" />
<img src="http://ecx.images-amazon.com/images/I/41BnyLL9T2L._SX258_BO1,204,203,200_.jpg" alt="Everybody Poops" /></p>

<h3>Everybody Poops</h3>

<p>For those of you who don&rsquo;t know, Everybody Poops is a popular potty training book for toddlers that catologues the pooping habits of man and beast.</p>

<p>I start here because when I first got interested in programming, I thought I might be good at it beacuse I was anal. Or more accuratly, anal retentive, a character trait that is meant to be aquired during the &lsquo;anal&rsquo; stage of development. From wikipedia:</p>

<blockquote><p>The term anal retentive (also anally retentive), commonly abbreviated to anal is used to describe a person who pays such attention to detail that the obsession becomes an annoyance to others, potentially to the detriment of the anal-retentive person.</p></blockquote>

<p>I can definitely be obsessive. I belive there is a right and wrong way to do things. Heck, I can even tend towards the obsessive compulsive at times. Did I turn the stove off?</p>

<h3>Anal retentive v methodical</h3>

<p>The more I meditate on being anal, and the more I learn to program, the more I think that being anal could be a liability and not an asset. From what I can tell at this point, being methodical is much more important than being obessive, and yes, they are very different things.</p>

<p>Asserting control over things like cleaning or safety can appear a virtue. You know, being fastidious and organized. Failing to prepare is prepairing to fail. But obsessing over the details of knowable, controllable thinigs like cleaning and safety is relatively easy. This is why obsessive behavior is annoying to others. To the unobsessed, this type of obessession feels like overkill. An unwarrented and intrusive allocation of energy to relativey small problems.</p>

<p>Methodology, on the other hand, is about applying a systematic or established procedure (aka method) to solve a problem. You do not have to wholly understand the thing you are dealing with to be methodical about finding a solution. Take an example from vertebrate taxonomy:</p>

<h3>Coelacanth</h3>

<p><img src="http://www.nhm.ac.uk/resources-rx/images/1008/coelacanth-latimeria-chalumnae_48064_2.jpg" alt="coelacanth" /></p>

<p>Thought to have been extinct for millions or years, coelacanths (aka the &ldquo;living fossil&rdquo;) were rediscoved swimming around the sea in the late 1930s. More closely related to landlubing creatures than typical fish, they are difficult to classify. Unable to quickly tidy them away into a preexisting understanding, the anal biologist might become overwhelmed when confronted with such a challange.</p>

<p>Althernatively, a methodical biologist could apply a series of procedures or methods to find a home for this old timer. Does it have feet? fins? lungs? gills? scales? skin? These individual questions are a set of methods for establishing the taxonomy of an animal. We can apply these methods to animals both known and unknown, and develop an understanding of their characteritics and habitats.</p>

<h3>POODR</h3>

<p>The complexity of technology and programming languages make them hard to obsessively control. And even if you manage to develop an encyclopedic understanding of today&rsquo;s technology, the constant change would eventually overwhelm even the deepest capacity for memorization. By developing a systematic, methodical means of approaching code, you don&rsquo;t have to worry about knowing everything or being in control. You can simply chip away at a big problem until it eventually becomes manageable.</p>

<p>I am coming to terms with the fact that the answers to code questions don&rsquo;t have to be knowable or neat at first. What I seek to find now is not the anwser, but a methodical means to find those anwers. The more I understand the art of programming, the more comfortable I become with the unknown.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tdd]]></title>
    <link href="http://richardsonjm.github.io/blog/2013/10/07/tdd/"/>
    <updated>2013-10-07T21:21:00-04:00</updated>
    <id>http://richardsonjm.github.io/blog/2013/10/07/tdd</id>
    <content type="html"><![CDATA[<h1>An introduction to TDD</h1>

<p>We have been doing a lot of Test Driven Development (TDD) at <a href="http://flatironschool.com/">Flatiron</a> the last few days. This <a href="https://speakerdeck.com/lvrug/introduction-to-tdd-jason-arhart">blog</a> post from Jason Arhart at the Las Vegas Ruby Group outlines some rules of TDD that will be good to keep in mind, especially as we get involved with more complicated projects.</p>

<p>Given that we have been writing code primarily to answer tests at this point (as opposed to writing the tests ourselves) this first rule hadn&rsquo;t totally sunk in:</p>

<ul>
<li>Never implement functionality until you have a failing test for it.</li>
</ul>


<p>In other words, the first step after concieving a feature is to write a test for that feature, and coding the actual feature itself.</p>

<ul>
<li>Only write enough of your test to make it fail</li>
</ul>


<p>This one was more intuitive for me. Keep the test as simple as possible so that the test functions as an aid to good development instead of a hinderance.</p>

<ul>
<li>Only write enough production code to make your test pass.</li>
</ul>


<p>As a corollary to the previous rule, this also make sense. In both the test and the production code, the code should be a simple and efficient as possible.</p>

<ul>
<li>Never refactor unless your tests are passing</li>
</ul>


<p>This final rule is my favorite. As I struggle to write elegant code, it&rsquo;s comforting to know that at the start the only thing that matters is that the code works.</p>

<p>I also really appreciate the philosophy behind this. Make it work first, then make it beautiful. This is also a good way to think about writing. Instead of perseverating over each sentence, just make sure to get all the ideas out. Then and only then, go back and make it eloquent.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello world]]></title>
    <link href="http://richardsonjm.github.io/blog/2013/09/25/hello-world/"/>
    <updated>2013-09-25T09:18:00-04:00</updated>
    <id>http://richardsonjm.github.io/blog/2013/09/25/hello-world</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
