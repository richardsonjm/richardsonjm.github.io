---
layout: post
title: "anal v methodical"
date: 2013-10-13 11:12
comments: true
categories: 
---
#POODR and Everybody Poops

![POODR](http://img1.imagesbn.com/p/9780321721334_p0_v2_s260x420.JPG)
![Everybody Poops](http://ecx.images-amazon.com/images/I/41BnyLL9T2L._SX258_BO1,204,203,200_.jpg)    
###Everybody Poops

For those of you who don't know, Everybody Poops is a popular potty training book for toddlers that catologues the pooping habits of man and beast. 

I start here because when I first got interested in programming, I thought I might be good at it beacuse I was anal. Or more accuratly, anal retentive, a character trait that is meant to be aquired during the 'anal' stage of development. From wikipedia:

>The term anal retentive (also anally retentive), commonly abbreviated to anal is used to describe a person who pays such attention to detail that the obsession becomes an annoyance to others, potentially to the detriment of the anal-retentive person.

I can definitely be obsessive. I belive there is a right and wrong way to do things. Heck, I can even tend towards the obsessive compulsive at times. Did I turn the stove off?


###Anal retentive v methodical
The more I meditate on being anal, and the more I learn to program, the more I think that being anal could be a liability and not an asset. From what I can tell at this point, being methodical is much more important than being obessive, and yes, they are very different things.

Asserting control over things like cleaning or safety can appear a virtue. You know, being fastidious and organized. Failing to prepare is prepairing to fail. But obsessing over the details of knowable, controllable thinigs like cleaning and safety is relatively easy. This is why obsessive behavior is annoying to others. To the unobsessed, this type of obessession feels like overkill. An unwarrented and intrusive allocation of energy to relativey small problems. 

Methodology, on the other hand, is about applying a systematic or established procedure (aka method) to solve a problem. You do not have to wholly understand the thing you are dealing with to be methodical about finding a solution. Take an example from vertebrate taxonomy:

###Coelacanth

![coelacanth](http://www.nhm.ac.uk/resources-rx/images/1008/coelacanth-latimeria-chalumnae_48064_2.jpg)

Thought to have been extinct for millions or years, coelacanths (aka the "living fossil") were rediscoved swimming around the sea in the late 1930s. More closely related to landlubing creatures than typical fish, they are difficult to classify. Unable to quickly tidy them away into a preexisting understanding, the anal biologist might become overwhelmed when confronted with such a challange. 

Althernatively, a methodical biologist could apply a series of procedures or methods to find a home for this old timer. Does it have feet? fins? lungs? gills? scales? skin? These individual questions are a set of methods for establishing the taxonomy of an animal. We can apply these methods to animals both known and unknown, and develop an understanding of their characteritics and habitats.

###POODR
The complexity of technology and programming languages make them hard to obsessively control. And even if you manage to develop an encyclopedic understanding of today's technology, the constant change would eventually overwhelm even the deepest capacity for memorization. By developing a systematic, methodical means of approaching code, you don't have to worry about knowing everything or being in control. You can simply chip away at a big problem until it eventually becomes manageable. 

I am coming to terms with the fact that the answers to code questions don't have to be knowable or neat at first. What I seek to find now is not the anwser, but a methodical means to find those anwers. The more I understand the art of programming, the more comfortable I become with the unknown.

